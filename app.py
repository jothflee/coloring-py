import io
import json
import pickle
from flask import Flask, render_template_string, send_file
import openai
import base64
import os
import requests
from PIL import Image
from io import BytesIO
from pdf import create_pdf_pages
import logging
from flask_basicauth import BasicAuth


# Set the DEBUG_GENERATE and DEBUG_PDF flags to False
DEBUG_GENERATE = False
DEBUG_PDF = False

# Create a Flask app instance
app = Flask(__name__)
the_port = 80
# Check if the SSL certificates are available
if os.path.exists('/certs/server.key') and os.path.exists('/certs/server.pem'):
    # Add SSL context to the app
    app.ssl_context = ('/certs/server.pem', '/certs/server.key')
    the_port = 443

# Set the OpenAI API key
openai.api_key = os.environ['OPENAI_API_KEY']

# Configure the logging module to log debug messages
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

app.config['BASIC_AUTH_USERNAME'] = 'username'
app.config['BASIC_AUTH_PASSWORD'] = 'password'
basic_auth = BasicAuth(app)

# Define a Flask route for the root URL


@app.route('/')
def index():
    return """
    <html><body>
    <a href='/generate'>generate one page</a><br>
    <a href='/pdf'>generate a pdf</a>
    </body></html>
    """


# Define a Flask route for the /pdf URL
@app.route('/pdf')
@basic_auth.required
def generate_pdf_route():
    # Generate the PDF using the generate_pdf function
    pdf_bytes = generate_pdf()

    # Return the PDF as a download to the user
    return send_file(
        io.BytesIO(pdf_bytes),
        mimetype='application/pdf',
        as_attachment=True,
        download_name='coloring_pages.pdf'
    )


# Define a Flask route for the /debug URL
@app.route('/debug', methods=['GET'])
@basic_auth.required
def debug():
    # Generate an image using the generate_image function
    generated_image = generate_image()

    # Return the generated image as a response
    return generated_image


# Define a Flask route for the /generate URL
@app.route('/generate', methods=['GET'])
@basic_auth.required
def generate():
    # Generate an image using the generate_image function
    generated_images = generate_image()

    if len(generated_images) == 0:
        return "No images generated"
    generated_image = generated_images[0]

    # Save the generated image to a file for debugging purposes
    generated_image.image.save("high.jpg")

    # Encode the generated image as a base64 string
    buffered = BytesIO()
    generated_image.image.save(buffered, format="JPEG")
    image_data = base64.b64encode(buffered.getvalue()).decode('utf-8')

    html = render_template_string('''
        <!DOCTYPE html>
        <html>
        <head>
            <title>Coloring Page</title>
        </head>
        <body>
            <div><img src="data:image/jpeg;base64,{{ image_data }}" alt="Coloring Page"></div>
            <h3>{{ caption }}</h3>
        </body>
        </html>
    ''', image_data=image_data, caption=generated_image.caption)

    # Return the HTML response
    return html


'''
Create a Python script that generates an image using DALL-E and OpenAI's GPT-3. 
The script should define a function called `generate_image` that takes no arguments. 
The function should use GPT-3 to generate a prompt that describes a nature scene featuring an animal or some other natural thing. 
The prompt should be used to generate an image using DALL-E. The function should then use GPT-3 to generate a caption for the image. 
The caption should summarize the image description provided in the prompt. 
The function should return the low-resolution image, the prompt, and the caption as a tuple. 
The DALL-E image should be generated using the OpenAI Image API with the prompt as input and a size of 1024x1024. 
The GPT-3 prompts should be generated using the OpenAI Chat API with the "gpt-3.5-turbo" model and a maximum of 100 tokens.
'''


# Define a class called GeneratedImage that represents an image generated by DALL-E
class GeneratedImage:
    def __init__(self, image, prompt, caption):
        self.image = image
        self.prompt = prompt
        self.caption = caption


# Define a function called generate_image that generates a list of GeneratedImage objects using DALL-E
def generate_image(num_images=1):
    # Define a list of messages to send to OpenAI's chat API to generate prompts
    messages = [
        {"role": "user", "content": "Output the generated prompts as a JSON array of strings."},
        {"role": "user", "content": f"Generate dalle prompts to generate portrait oriented images of nature's beauty, animals, and the earth."},
        {"role": "user", "content": "Each prompt shoudl be 10 words or less."},
        {"role": "user", "content": "Example of a prompt: A graceful deer dances through a sunlit meadow of wildflowers."},
        {"role": "user",
            "content": f"Generate exactly {num_images} prompt(s), the length of the JSON array is {num_images}."},
    ]

    # Send the messages to OpenAI's chat API to generate prompts
    prompt_response = openai.ChatCompletion.create(
        # You may need to update the engine depending on the latest available version
        model="gpt-3.5-turbo",
        messages=messages,
        max_tokens=150*num_images
    )

    # Parse the generated prompts from the response
    prompts_response = prompt_response.choices[0].message.content
    logging.debug("Generated prompts: %s", prompts_response)
    prompts = json.loads(prompts_response)

    # Generate an image for each prompt using DALL-E
    imgs = []
    for prompt in prompts:
        # Generate the image using DALL-E
        response = openai.Image.create(
            prompt=f'{prompt} As a complex coloring page, outlines only, in black and white or grey scale.',
            n=1,
            size='512x512',
        )

        # Get the image data and encode it as base64
        image_response = requests.get(response['data'][0]['url']).content
        low_res_img = Image.open(BytesIO(image_response))

        # Create a new GeneratedImage object and add it to the list of images
        imgs.append(GeneratedImage(low_res_img, prompt, prompt))
        logging.debug("Generated image with prompt '%s'", prompt)

    # Return the list of generated images
    return imgs


'''
Create a function called 'generate_pdf' that generates a multi-page PDF with one page for each image and caption.
It uses the function 'create_pdf_pages' from the pdf.py file to create the pdf.
create_pdf_pages returns a buffer of bytes, generate_pdf will return a buffer of bytes.
It uses the function 'generate_image' to generate the images and captions using the GeneratedImage class (image, caption, prompt).
It has 1 input num_pages which defaults to 5
Add debug logging for each line.
Add comments to explain each line.
'''

# Define a function called generate_pdf that takes an optional argument num_pages and returns a buffer of bytes


def generate_pdf(num_pages=20) -> bytes:
    logging.debug("Generating PDF with %d pages", num_pages)

    # Generate a list of GeneratedImage objects
    pages = []
    generated_images = generate_image(num_pages)

    # Loop over the generated images and add them to the pages list
    for i in range(num_pages):
        generated_image = generated_images[i]

        # If DEBUG_GENERATE is True, save the generated image to a pickle file for debugging purposes
        if DEBUG_GENERATE:
            f = open(f"generated_image_{i}.pickle", "wb")
            pickle.dump(generated_image, f)
            f.close()

        # If DEBUG_PDF is True, load the generated image from a pickle file for debugging purposes
        if DEBUG_PDF:
            f = open(f"generated_image_{i}.pickle", "rb")
            generated_image = pickle.load(f)
            f.close()

        # Add the generated image to the pages list and log a message
        pages.append(generated_image)
        logging.debug("Generated image %d with caption '%s'",
                      i+1, generated_image.caption)

    # Generate the PDF using the create_pdf_pages function
    pdf_bytes = create_pdf_pages(pages)
    logging.debug("Generated PDF with %d bytes", len(pdf_bytes))

    # Return the PDF as a buffer of bytes
    return pdf_bytes


# If this script is run directly, start the Flask app
if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=False, port=the_port)
